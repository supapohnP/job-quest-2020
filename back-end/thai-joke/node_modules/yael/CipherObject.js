// Generated by CoffeeScript 1.10.0
(function() {
  var BufSlicer, CipherObject, E, buf2str, semver, str2buf;

  semver = require('semver');

  E = require('./constants');

  buf2str = function(buf, enc) {
    if (enc == null) {
      enc = 'base64';
    }
    if (!Buffer.isEncoding(enc)) {
      throw new Error("CipherObject: buf2str Buffer.isEncoding('" + enc + "') returned false.");
    }
    return ":" + enc + ":" + (buf.toString(enc));
  };

  str2buf = function(str) {
    var enc, m;
    m = str.match(/^:(.*):/);
    if (m == null) {
      throw new Error("CipherObject: str2buf run on string but no :encoding: found at start");
    }
    enc = m[1];
    if (!Buffer.isEncoding(enc)) {
      throw new Error("CipherObject: str2buf run on string with encoding :" + enc + ": but Buffer.isEncoding('" + enc + "') returned false.");
    }
    str = str.slice(m[0].length);
    return new Buffer(str, enc);
  };

  BufSlicer = (function() {
    function BufSlicer(buf1, beg, end) {
      this.buf = buf1;
      this.beg = beg != null ? beg : 0;
      this.end = end != null ? end : 0;
    }

    BufSlicer.prototype.slice = function(len) {
      this.beg = this.end;
      this.end = len != null ? this.end + len : this.buf.length;
      return this.buf.slice(this.beg, this.end);
    };

    return BufSlicer;

  })();

  CipherObject = (function() {
    function CipherObject(o) {
      var p;
      switch (false) {
        case !(o instanceof Buffer):
          return this.fromBuffer(o);
        case typeof o !== 'string':
          return this.fromString(o);
        case typeof o !== 'object':
          for (p in o) {
            if (typeof o[p] !== 'function') {
              this[p] = o[p];
            }
          }
      }
    }

    CipherObject.prototype.toString = function() {
      return JSON.stringify({
        yael_version: this.yael_version,
        cipherfile: buf2str(this.cipherfile),
        iv: buf2str(this.iv),
        salt: buf2str(this.salt),
        authtag: buf2str(this.authtag),
        return_type: this.return_type,
        details: this.details
      });
    };

    CipherObject.prototype.fromString = function(o) {
      var error, json, p;
      try {
        json = JSON.parse(o);
      } catch (error) {
        throw new Error("CipherObject.fromString: Invalid JSON");
      }
      for (p in json) {
        this[p] = json[p];
      }
      this.cipherfile = str2buf(this.cipherfile);
      this.iv = str2buf(this.iv);
      this.salt = str2buf(this.salt);
      this.authtag = str2buf(this.authtag);
      return this;
    };

    CipherObject.prototype.toBuffer = function() {
      var t, v;
      v = semver.parse(this.yael_version);
      t = this.return_type[0];
      return Buffer.concat([new Buffer([v.major, v.minor, v.patch]), new Buffer(t), this.salt, this.iv, this.authtag, this.cipherfile]);
    };

    CipherObject.prototype.fromBuffer = function(o) {
      var buf, major, minor, patch, ref, return_type;
      buf = new BufSlicer(o);
      ref = buf.slice(3), major = ref[0], minor = ref[1], patch = ref[2];
      this.yael_version = major + '.' + minor + '.' + patch;
      return_type = buf.slice(1);
      this.return_type = (function() {
        switch (return_type.toString()) {
          case 'S':
            return 'String';
          case 'B':
            return 'Buffer';
        }
      })();
      this.salt = buf.slice(E.SALT_LENGTH);
      this.iv = buf.slice(E.IV_LENGTH);
      this.authtag = buf.slice(E.AUTHTAG_LENGTH);
      this.cipherfile = buf.slice();
      this.details = {
        CIPHER_ALGORITHM: E.CIPHER_ALGORITHM,
        SALT_LENGTH: E.SALT_LENGTH,
        IV_LENGTH: E.IV_LENGTH,
        KEY_LENGTH: E.KEY_LENGTH,
        HASH_ALGORITHM: E.HASH_ALGORITHM,
        ITERATIONS: E.ITERATIONS
      };
      return this;
    };

    return CipherObject;

  })();

  module.exports = CipherObject;

}).call(this);
